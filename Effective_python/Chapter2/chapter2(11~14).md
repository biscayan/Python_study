# Chapter 2. 리스트와 딕셔너리 (Better way 11 ~ 14)

## 11. 시퀀스를 슬라이싱하는 방법을 익혀라
리스트의 맨 앞부터 슬라이싱할 때는 시각적 잡음을 없애기 위해 0을 생략하고, 리스트의 끝까지 슬라이싱할 때는 쓸데없이 끝 인덱스를 적지 말라
```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5]
a[5:]
```
```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

print(a[:]) ### 전체
>>> 
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

print(a[-3:]) ### 뒤에 3개만
>>>
['f', 'g', 'h']

print(a[-3:-1]) ### 뒤에 3개에서 마지막것은 빼고
['f', 'g']
```
리스트를 슬라이싱한 결과는 완전히 새로운 리스트이며, 원래 리스트에 대한 참조는 그대로 유지된다. 즉, 슬라이싱한 결과로 얻은 리스트를 변경해도 원래 리스트는 바뀌지 않는다.  
하지만, 기존 리스트에 값을 대입하면 리스트의 원소들이 바뀌게 된다.  
만약 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 짧으면 리스트가 줄어들게 된다.
```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('이전:', a)
a[2:7] = [10,100]
print('이후:', a)

>>>
이전: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
이후: ['a', 'b', 10, 100, 'h']
```
반대로, 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 길면 리스트가 늘어나게 된다.
```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('이전:', a)
a[2:4] = [10,11,12,13,14,15]
print('이후:', a)

>>>
이전: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
이후: ['a', 'b', 10, 11, 12, 13, 14, 15, 'e', 'f', 'g', 'h']
```
슬라이싱에서 시작과 끝 인덱스를 모두 생략하면 원래 리스트를 복사한 새 리스트가 생성되지만, 시작과 끝 인덱스가 없는 슬라이스에 대입하면 새 리스트를 만들어내는 대신 슬라이스가 참조하는 리스트의 내용을 대입하는 리스트의 복사본으로 덮어 쓴다.
```python

a = [1,2,3,4,5,6,7,8,9,10]

### 새로운 리스트가 생성됨
b = a[:]

print('이전 a', a)
print('이전 b', b)

a[:] = [101, 102, 103]

print('이후 a ', a) 
print('이후 b ', b) 

>>>
이전 a [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
이전 b [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
이후 a  [101, 102, 103]
이후 b  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
```python
a = [1,2,3,4,5,6,7,8,9,10]

### a의 복사본이 만들어짐
b = a

print('이전 a', a)
print('이전 b', b)

a[:] = [101, 102, 103]

print('이후 a ', a) 
print('이후 b ', b) 

>>>
이전 a [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
이전 b [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
이후 a  [101, 102, 103]
이후 b  [101, 102, 103]
```

## 12. 스트라이드와 슬라이스를 한 식에 함께 사용하지 말라
파이썬은 리스트[시작:끝:증가값]를 일정한 간격을 두고 슬라이싱을 할 수 있는 특별한 구문을 제공하는데, 이를 스트라이드라고 한다.  
x[-2:2:-2]처럼 슬라이싱 구문에 스트라이딩까지 들어가면 아주 혼란스럽다. 각 괄호 안에 수가 세 개나 들어 있으면 코드 밀도가 너무 높아서 읽기 어렵다.  
이러한 문제를 방지하기 위해 시작값이나 끝값을 증가값과 함께 사용하지 말 것을 권한다.  

## 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라
파이썬은 별표 식(asterisk)을 사용해 모든 값을 담은 언패킹을 할 수 있게 지원한다.  
```python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
car_ages_desc = sorted(car_ages, reverse = True)
oldest, second_oldest, *others = car_age_desc
print(oldest, second_oldest, *others)

>>>
20 19 [15, 9, 8, 7, 6, 4, 1, 0]
```
하지만 별표 식은 항상 리스트를 만들어내기 때문에 이터레이터를 별표 식으로 언패킹하면 컴퓨터 메모리를 모두 다 사용해서 프로그램이 멈출 수 있다. 따라서 결과 데이터가 모두 메모리에 들어갈 수 있다고 확신할 때만 나머지를 모두 잡아내는 언패킹을 사용해야 한다.

## 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라
key 함수에는 정렬 중인 리스트의 원소가 전달된다. key 함수가 반환하는 값은 원소 대신 정렬 기준으로 사용할, 비교 가능한 (자연스러운 순서가 정의된) 값이어야만 한다.  
key로 전달된 람다 함수 내부에서는 원소 애트리뷰트에 접근하거나, 인덱스를 써서 값을 얻거나 (시퀀스, 튜플, 딕셔너리인 경우), 제대로 작동하는 다른 모든 식을 사용할 수 있다.  
만약 여러 기준을 사용해 정렬해야 할때는 tuple 타입을 사용하는 것이 편리하다.
```python 
# power_tools의 원소들을 (1) weight을 기준으로 내림차순 정렬한 다음에 (2) name을 기준으로 오름차순 정렬
power_tools.sort(key = lambda x: (-x.weight, x.name))
```